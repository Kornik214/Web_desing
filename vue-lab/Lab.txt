ЗВІТ З ЛАБОРАТОРНОЇ РОБОТИ №4

Кроки виконання роботи

Ініціалізація проєкту: За допомогою інструменту create-vue створено новий проєкт. В налаштуваннях активовано підтримку TypeScript 
та Vue Router.

Встановлення залежностей: Виконано команду npm install для завантаження необхідних бібліотек.

Первинний запуск: Здійснено тестовий запуск сервера розробки (npm run dev) для перевірки працездатності базової версії застосунку,
 після чого сервер було зупинено.

Аналіз структури: Ознайомлено з архітектурою згенерованого проєкту та призначенням основних директорій 
(src/views, src/router, src/components).

Створення нової сторінки:

Створено файл ContactView.vue у директорії views.

Зареєстровано новий маршрут /contact у конфігурації роутера (router/index.ts).

Додано навігаційне посилання <RouterLink> у головному компоненті App.vue.

Проміжна перевірка: Перевірено коректність навігації на нову сторінку без перезавантаження браузера.

Розробка компонентів:

Створено компонент UserCard.vue з використанням TypeScript (defineProps) для типізації вхідних даних.

Оновлено ContactView.vue для імпорту та відображення створеного компонента.

Фінальне тестування: Запущено проєкт та перевірено відображення карток користувачів і коректність стилів.

Текст Помилки
    Type 'number' is not assignable to type 'boolean'.
    (property) isActive boolean

Це демонструє роботу механізму статичної типізації, який попереджає про невідповідність типів даних ще на етапі написання коду.

ВИСНОВКИ

У ході виконання лабораторної роботи було набуто практичних навичок розробки веб-застосунків на базі Vue 3:

TypeScript: Використання TypeScript дозволило додати сувору типізацію до JavaScript-коду. Це значно підвищує надійність проєкту,
 дозволяючи виявляти помилки на етапі компіляції, покращує читабельність коду та спрощує підтримку великих застосунків завдяки автодоповненню та самодокументуванню компонентів.

Vue Router: Інтеграція маршрутизатора забезпечила реалізацію архітектури SPA (Single Page Application). Це дозволило налаштувати
навігацію між компонентами без повного перезавантаження сторінки, що забезпечує високу швидкодію інтерфейсу та 
покращує користувацький досвід. Також було застосовано технологію "лінивого завантаження" (lazy loading) для оптимізації
ресурсів.


ЗВІТ З ЛАБОРАТОРНОЇ РОБОТИ №5


КРОКИ ВИКОНАННЯ РОБОТИ

1.1. Інсталяція та налаштування Tailwind CSS
Для інтеграції бібліотеки у проєкт було виконано наступні кроки:

Встановлення пакетів: Через термінал виконано команду npm install -D tailwindcss postcss autoprefixer, щоб додати необхідні інструменти розробки.

Ініціалізація конфігурації: Виконано команду npx tailwindcss init -p, яка створила файли налаштувань tailwind.config.js та postcss.config.js.

Налаштування шляхів: У файлі tailwind.config.js у масиві content вказано шляхи до всіх файлів, де можуть використовуватися класи (./index.html, ./src/**/*.{vue,js,ts,jsx,tsx}), щоб Tailwind знав, які файли сканувати.

Підключення стилів: У головний CSS-файл (src/assets/main.css) додано директиви:

@tailwind base;
@tailwind components;
@tailwind utilities;


1.2. Реалізація умовних стилів у UserCard.vue
Для відображення статусу "Активний/Неактивний" було замінено звичайні CSS-класи на динамічну прив'язку утилітарних класів Tailwind.
У шаблоні використано тернарний оператор:

<div :class="isActive ? 'border-green-500 bg-green-50' : 'border-gray-200'">


Логіка роботи:

Якщо isActive === true: елементу додається зелена рамка (border-green-500) та світло-зелений фон (bg-green-50).

Якщо isActive === false: елемент отримує нейтральну сіру рамку (border-gray-200).
Це дозволило повністю відмовитися від блоку <style> у цьому компоненті.

ПОРІВНЯЛЬНИЙ АНАЛІЗ: Utility-first (Tailwind) vs <style scoped>

Переваги підходу Tailwind CSS:

Швидкість розробки: Не потрібно вигадувати семантичні назви класів (як у методології BEM) та перемикатися між HTML і CSS файлами. Стилі пишуться прямо в шаблоні.

Дизайн-система: Tailwind надає готову, збалансовану систему відступів, кольорів та типографіки, що робить вигляд застосунку консистентним (цілісним).

Оптимізація: У фінальну збірку потрапляють лише ті стилі, які дійсно використовуються в проєкті (завдяки механізму PurgeCSS), тоді як при написанні звичайного CSS часто залишається "мертвий код".

Недоліки:

Забруднення HTML: Код шаблону стає довшим і складнішим для читання через велику кількість класів (наприклад, flex items-center justify-between p-4 shadow-sm).

Поріг входження: Необхідно вивчити назви класів бібліотеки (хоча розширення для VS Code значно спрощують це).

БОНУСНЕ ЗАВДАННЯ (Темна тема)

[Місце для вашого скріншоту темної теми]
Опис реалізації: Додано підтримку темного режиму за допомогою модифікатора dark:. Наприклад, для фону використано клас dark:bg-slate-800, а для тексту dark:text-white.

ВИСНОВКИ

В ході виконання лабораторної роботи №5 було успішно інтегровано фреймворк Tailwind CSS у проєкт на Vue 3. Це дозволило спростити процес стилізації компонентів,
відмовившись від написання кастомного CSS коду. Було практично закріплено навички роботи з умовним рендерингом класів та налаштуванням конфігураційних файлів сучасних frontend-інструментів.